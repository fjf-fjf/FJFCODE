// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.2
// LVGL version: 8.3.11
// Project name: SquareLine_Project

#include "ui.h"

// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.2
// LVGL version: 8.3.11
// Project name: SquareLine_Project

#include "ui.h"
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <time.h>
#include <stdio.h>
#include <string.h>
#include <unistd.h> //close
#include <pthread.h>
#include <sys/types.h>    //socket      /* See NOTES */
#include <sys/socket.h>
#include <sys/socket.h> //man 3 inet_addr
#include <netinet/in.h>
#include <arpa/inet.h>


#define BUFSIZE 4096
#define API_KEY "a7f40acc995887c70487915115eec5b7"
#define HTTP_PORT 80
#define SERVER_PATH "/webservice/sms.php"
#define SERVER_DOMAIN "106.ihuyi.com"
#define SERVER_apid "C02912837"
#define SERVER_IP   "192.168.60.198" //ubuntu
#define SERVER_PORT 60000

int create_and_connect() {
    int tcp_socket = socket(AF_INET, SOCK_STREAM, 0);
    if (tcp_socket == -1) {
        fprintf(stderr, "创建socket失败: %s\n", strerror(errno));
        exit(EXIT_FAILURE);
    }

    struct hostent *server = gethostbyname(SERVER_DOMAIN);
    if (!server) {
        fprintf(stderr, "无法解析域名: %s\n", SERVER_DOMAIN);
        close(tcp_socket);
        exit(EXIT_FAILURE);
    }

    struct sockaddr_in dest = {0};
    dest.sin_family = AF_INET;
    dest.sin_port = htons(HTTP_PORT);
    memcpy(&dest.sin_addr, server->h_addr_list[0], server->h_length);

    if (connect(tcp_socket, (struct sockaddr *)&dest, sizeof(dest)) == -1) {
        fprintf(stderr, "连接失败: %s\n", strerror(errno));
        close(tcp_socket);
        exit(EXIT_FAILURE);
    }

    return tcp_socket;
}

void get_code(lv_event_t * e)
{
    char recvbuf[BUFSIZE] = {0};
    char request[BUFSIZE] = {0};

    int tcp_socket = create_and_connect();

    char phone[100] = {0};
    // 从文件中读取手机号
    FILE *fp = fopen("/tmp/1.txt", "r"); // 修改为仅读取模式
    if (fp == NULL) {
        fprintf(stderr, "无法打开文件: %s\n", strerror(errno));
        close(tcp_socket);
        exit(EXIT_FAILURE);
    }

    // 读取文件内容到phone变量
    if (fgets(phone, sizeof(phone), fp) != NULL) {
        // 去除换行符
        phone[strcspn(phone, "\n")] = 0;
    } else {
        fprintf(stderr, "无法读取文件: %s\n", strerror(errno));
        fclose(fp);
        close(tcp_socket);
        exit(EXIT_FAILURE);
    }

    fclose(fp);

    // 生成随机验证码
    srand(time(NULL));
    int verification_code = rand() % 9000 + 1000; // 生成4位验证码

    // 短信内容模板（保留占位符）
    char content[100];
    snprintf(content, sizeof(content), "您的验证码是：%d。请不要把验证码泄露给其他人。", verification_code);

    // 打印短信内容（调试用）
    printf("短信内容: %s\n", content);

    // 构造HTTP请求
    char *post_data = 
        "method=Submit&account=%s&password=%s&mobile=%s&content=%s&para=%d&format=json";
    int post_len = snprintf(NULL, 0, post_data, SERVER_apid, API_KEY, phone, content, verification_code);
    post_data = malloc(post_len + 1);
    snprintf(post_data, post_len + 1, 
        "method=Submit&account=%s&password=%s&mobile=%s&content=%s&para=%d&format=json",
        SERVER_apid, API_KEY, phone, content, verification_code);

    snprintf(request, sizeof(request),
        "POST %s HTTP/1.1\r\n"
        "Host: %s\r\n"
        "Content-Type: application/x-www-form-urlencoded\r\n"
        "Connection: close\r\n"
        "Content-Length: %d\r\n"
        "\r\n"
        "%s",
        SERVER_PATH, SERVER_DOMAIN, post_len, post_data);

    free(post_data);

    if (send(tcp_socket, request, strlen(request), 0) == -1) {
        fprintf(stderr, "发送失败: %s\n", strerror(errno));
        close(tcp_socket);
    }

    int total = 0, received;
    while ((received = recv(tcp_socket, recvbuf + total, BUFSIZE - total - 1, 0)) > 0) {
        total += received;
        if (total >= BUFSIZE - 1) break;
    }

    if (received == -1) 
	{
        fprintf(stderr, "接收错误: %s\n", strerror(errno));
        close(tcp_socket);
    }
    recvbuf[total] = '\0';

    char *json = strstr(recvbuf, "\r\n\r\n");
    if (json) {
        json += 4;
        printf("\n=== 响应数据 ===\n%s\n", json);
    } else {
        printf("\n=== 原始响应 ===\n%s\n", recvbuf);
    }

    close(tcp_socket);
    memset(recvbuf, 0, sizeof(recvbuf));

    // 将验证码写入2.txt文件中，覆盖原有内容
    FILE *file = fopen("/tmp/2.txt", "w"); // 修改为写入模式
    if (file == NULL) {
        fprintf(stderr, "无法打开文件: %s\n", strerror(errno));
        exit(EXIT_FAILURE);
    }

    // 写入验证码到文件
    fprintf(file, "%d\n", verification_code);

    fclose(file);

    return 0;
}



char * tcp_jie(char *buf)
{
    int ret = 0;
    //1.新建套接字--socket
    //地址族ipv4:AF_INET  协议tcp：SOCK_STREAM
    int socket_fd = socket(AF_INET,SOCK_STREAM,0);
    if(socket_fd < 0)
    {
        //printf("socket fail\n");
        //return -1;
    }
	int optval = 1;
	setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR,&optval, sizeof(optval));
	
    //填充自己(服务器)的地址和端口---用新的结构体(难点)
    struct sockaddr_in server_addr;
    server_addr.sin_family = AF_INET; //ipv4地址族
    server_addr.sin_port = htons(SERVER_PORT);//服务器的端口号(将本机端口号转换为网络端口号):小端字节序-->大端字节序
    server_addr.sin_addr.s_addr = inet_addr(SERVER_IP);//服务器的IP(将本机IP转换为网络IP):小端字节序-->大端字节序
    //2.绑定本机IP和端口(让服务器固定身份)--手机号 bind
    ret = bind(socket_fd,(struct sockaddr *)&server_addr,sizeof(struct sockaddr_in));
    if(ret < 0)
    {
        printf("bind fail\n");
        return -1;
    }
    printf("bind succcess [%s][%d]\n",SERVER_IP,SERVER_PORT);
    //3.监听 -- 设置设置铃声 listen
    ret = listen(socket_fd,20);
    if(ret < 0)
    {
        printf("listen fail\n");
        return -1;
    }   
    //4.接收客户端的链接(启动服务器) accept
    int socket_client = 0; //用来存客户端的套接字
    socket_client = accept(socket_fd,NULL,NULL); //要知道谁给我发的(复杂的写法)
    if(socket_client < 0)
    {
        printf("accept fail\n");
        return -1;
    }      
	//5.接收客户端的数据 -- recv/read
	memset(buf,0,128);
	ret = recv(socket_client,buf,128,0);//recv的sockfd是你要接收的客户端的套接字不是socket_fd
	if(ret < 0)
	{
		printf("recv fail\n");
	}
    //6.关闭套接字 --close
    close(socket_client);
    close(socket_fd);
    return buf;
}







void openvideo(lv_event_t * e)
{
    //加载屏幕3
    ui_Screen3_screen_init();
    lv_scr_load(ui_Screen3);
	system("./openvideo");
    //加载屏幕一
    lv_scr_load(ui_Screen1);
}

char buf[128] = {0};
void * openaifuction(void *arg)
{
    while(1)
    {
        memset(buf,0,128);
        tcp_jie(buf);
        if(strstr(buf,"摄像")!=NULL)
        {
            //加载屏幕3
            ui_Screen6_screen_init();
             lv_scr_load(ui_Screen6);
            system("./openvideo");
             lv_scr_load(ui_Screen1);
            
        }
        else if(strstr(buf,"相册")!=NULL)
        {
           
            ui_Screen5_screen_init();
            lv_scr_load(ui_Screen5);
            system("./q5");
            lv_scr_load(ui_Screen1);
        }
        else if(strstr(buf,"视频")!=NULL)
        {
           //加载屏幕2
           ui_Screen6_screen_init();
           lv_scr_load(ui_Screen6);
            system("./q6");
            lv_scr_load(ui_Screen1);
        }
        else if(strstr(buf,"紧急求救")!=NULL)
        {
           //加载屏幕2
            ui_Screen3_screen_init();
            lv_scr_load(ui_Screen3);
            system("./yzm");
            lv_scr_load(ui_Screen1);
        }
        else if(strstr(buf,"座椅加热")!=NULL)
        {
           //加载屏幕2
            ui_Screen4_screen_init();
            lv_scr_load(ui_Screen4);
            
        }

    }	
}





void opendaohang(lv_event_t * e)
{
	FILE *file = fopen("/tmp/6.txt", "w"); // 以写模式打开文件
    if (file == NULL) {
        perror("无法打开文件"); // 如果文件打开失败，打印错误信息
        return;
    }

    fprintf(file, "0\n"); // 向文件写入数据 "0"

    if (fclose(file) != 0) {
        perror("无法关闭文件"); // 如果文件关闭失败，打印错误信息
    }
}

void openbmps(lv_event_t * e)
{
	//加载屏幕2
    ui_Screen2_screen_init();
    lv_scr_load(ui_Screen2);
    system("./q5");
    lv_scr_load(ui_Screen1);
}

void openSOSfuction(lv_event_t * e)
{
	system("./yzm");
}





void openshipin(lv_event_t * e)
{
	//加载屏幕2
    ui_Screen2_screen_init();
    lv_scr_load(ui_Screen2);
    system("./q6");
    lv_scr_load(ui_Screen1);
}


#include <stdio.h>

void fasongxiaoxi(lv_event_t * e)
{
    FILE *file = fopen("/tmp/6.txt", "w"); // 以写模式打开文件
    if (file == NULL) {
        perror("无法打开文件"); // 如果文件打开失败，打印错误信息
        return;
    }

    fprintf(file, "1\n"); // 向文件写入数据 "1"

    if (fclose(file) != 0) {
        perror("无法关闭文件"); // 如果文件关闭失败，打印错误信息
    }
}
